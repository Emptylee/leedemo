<!DOCTYPE html>
<html lang="en">
<head>
	<meta http-equiv="Content-Type" content="text/html;charset=utf-8">
	<title>飞机大战</title>
<style>
	div{width:480px;margin:0 auto;}
</style>
</head>
<body>
	<div>
		<canvas id="canvas" width="480" height="650"></canvas>
	</div>
</body>
<script>
	//定义宽和高 以后说不定有用
	var WIDTH=480,HEIGHT=650;
	var score=0,life=3;
	//定义状态
	var START=0;
	var STARTING=1;
	var RUNNING=2;
	var PAUSE=3;
	var GAME_OVER=4;

	/*state表示游戏的状态 取值必须为以上五种状态之一*/
	var state=START;
/****************************************************************************************/

	//获取数据
	var canvas=document.getElementById("canvas");
	ctx=canvas.getContext("2d");
	
	//创建图像对象用来表示天空，英雄，敌人
	var bg=new Image();//背景
	bg.src="images/bg_01.jpg";

	var copyright=new Image();//版权
	copyright.src="images/copyright.png";

	var l=[];//starting
	l[0]=new Image();
	l[0].src="images/loading1.png";
	l[1]=new Image();
	l[1].src="images/loading2.png";
	l[2]=new Image();
	l[2].src="images/loading3.png";
	l[3]=new Image();
	l[3].src="images/loading4.png";

	var h=[];//hero
	h[0]=new Image();
	h[0].src="images/hero1.png";
	h[1]=new Image();
	h[1].src="images/hero2.png";
	h[2]=new Image();
	h[2].src="images/hero3.png";
	h[3]=new Image();
	h[3].src="images/hero4.png";
	h[4]=new Image();
	h[4].src="images/hero5.png";
	h[5]=new Image();
	h[5].src="images/hero6.png";

	var b=new Image();//bullet
	b.src="images/bullet.png";

	var bullets=[];//保存由hero发射的所有子弹

	var p=[];//pause
	p[0]=new Image();
	p[0].src="images/pause.png";
	p[1]=new Image();
	p[1].src="images/pause2.png";

	var e1=[];//小飞机
	e1[0]=new Image();
	e1[0].src="images/enemy1.png";
	e1[1]=new Image();
	e1[1].src="images/enemy2.png";
	e1[2]=new Image();
	e1[2].src="images/enemy3.png";
	e1[3]=new Image();
	e1[3].src="images/enemy4.png";
	e1[4]=new Image();
	e1[4].src="images/enemy5.png";

	var e2=[];//中飞机
	e2[0]=new Image();
	e2[0].src="images/enemy6.png";
	e2[1]=new Image();
	e2[1].src="images/enemy7.png";
	e2[2]=new Image();
	e2[2].src="images/enemy8.png";
	e2[3]=new Image();
	e2[3].src="images/enemy9.png";
	e2[4]=new Image();
	e2[4].src="images/enemy10.png";

	var e3=[];//大飞机
	e3[0]=new Image();
	e3[0].src="images/enemy11.png";
	e3[1]=new Image();
	e3[1].src="images/enemy12.png"; 
	e3[2]=new Image();
	e3[2].src="images/enemy13.png"; 
	e3[3]=new Image();
	e3[3].src="images/enemy14.png"; 
	e3[4]=new Image();
	e3[4].src="images/enemy15.png"; 
	e3[5]=new Image();
	e3[5].src="images/enemy16.png"; 
	e3[6]=new Image();
	e3[6].src="images/enemy17.png"; 
	e3[7]=new Image();
	e3[7].src="images/enemy18.png";

	var enemies=[]; 
/****************************************************************************************/

	//数据对象
	var SKY={image:bg,width:480,height:650,speed:20};
	
	var LOADING={frames:l,width:92,height:20,x:0,y:HEIGHT-20,speed:5};
	
	var HERO={frames: h,baseFrameCount:2,width:108,height:137,speed:20};

	var BULLET={image:b,width:7,height:18};

	var PAUSEOBJ={frames:p,width:80,height:80,speed:20,baseFrameCount:2};

	var E1={type:1,score:1,frames:e1,baseFrameCount:1,life:1,minSpeed:70,maxSpeed:100,width:55,height:40};

	var E2={type:2,score:5,frames:e2,baseFrameCount:1,life:5,minSpeed:50,maxSpeed:70,width:80,height:97};

	var E3={type:3,score:20,frames:e3,baseFrameCount:2,life:20,speed:15,width:180,height:265};
/**************************************************************************************/
	//业务对象

	/*一 天空的业务对象  config表示天空的业务对象*/
	var Sky=function(config){
		this.bg=config.image;//设置背景图像
		this.width=config.width;
		this.height=config.height;
		this.speed=1000/config.speed;
		this.x1=0;
		this.x2=0;
		this.y1=0;
		this.y2=-this.height;
		this.lastTime=0;//上一次执行动作时间的毫秒数

		/*专门负责背景走动
		 *移动背景纵坐标
		 */
		this.step=function(){
			//判断是否到达天空移动的时间
			var currentTime=new Date().getTime();
			if(currentTime-this.lastTime>=this.speed){
				this.y1++;
				this.y2++;
				this.lastTime=new Date().getTime();
			}
			/*以上这段是用new Date().getTime()的方法来控制背景的移动 为什么要这么做呢。因为整个游戏就用一个setInterval来定时，则每个对象如背景英雄敌人等都要设置各自的速度，否则大家的速度都用的是setInterval的速度即1000/100即10毫秒 则相对位置不会变了以上代码要注意的是this.lastTime=new Date().getTime();这句话在if里面 其作用是取到完成一次移动后的时间点 第一次肯定是++这没问题，接下去lastTime存入++后的时间点 接着10毫秒后再次运行 由于间隔较短 if条件不满足 不会++ 再过若干个10毫秒 if满足条件 则++ lastTime此时才更新为新的++后的时间点 最后当间隔时间大于等于背景的速度时再++*/
			//判断y1,y2是否超出范围
			if(this.y1>=this.height){
				this.y1=-this.height;
			}
			if(this.y2>=this.height){
				this.y2=-this.height;
			}
		}

		//绘制图像专门专门负责画
		/*ctx:canvas上下文*/
		this.paint=function(ctx){
			ctx.drawImage(this.bg,this.x1,this.y1);
			ctx.drawImage(this.bg,this.x2,this.y2);
		}
	}

	/*二 加载starting的业务对象*/
	var Loading=function(config){
		this.x=config.x;
		this.y=config.y;
		this.speed=1000/config.speed;
		this.lastTime=0;
		this.frame=null;
		this.frameIndex=0;
		//更换loading图像
		this.step=function(){
			var currentTime=new Date().getTime();
			if(currentTime-this.lastTime>=this.speed){
				//获取不同图像config.frames中的元素给frame
				this.frame=config.frames[this.frameIndex];
				this.frameIndex++;
				if(this.frameIndex>=4){
					//更新状态
					state=RUNNING;
				}
				this.lastTime=new Date().getTime();
			}
		}
		//绘制不同的图像到canvas上
		this.paint=function(ctx){
			ctx.drawImage(this.frame,this.x,this.y);
		}
	}

	/*三 hero*/
	var Hero=function(config){
		this.frames=config.frames;
		this.frameIndex=0;
		this.baseFrameCount=config.baseFrameCount;
		this.width=config.width;
		this.height=config.height;
		this.speed=1000/config.speed;
		this.x=(WIDTH-this.width)/2;
		this.y=HEIGHT-this.height-30;
		this.lastTime=0;

		this.down=false;
		this.canDelete=false;

		this.step=function(){
			var currentTime=new Date().getTime();
			if(currentTime-this.lastTime>=this.speed){
				if(this.down){
					//爆炸状态
					if(this.frameIndex==this.frames.length){
						this.canDelete=true;
					}else{
						this.frame=this.frames[this.frameIndex];
						this.frameIndex++;
					}
				}else{
					this.frame=this.frames[this.frameIndex%this.baseFrameCount];
					this.frameIndex++;
					//这里用了baseFrameCount=2 即任何正整数除以2 余数为0或1（注意0除以2余0），这样可以让frameIndex不断++，不断得出0或1 使得两幅hero图片交替出现造成喷气效果
					this.lastTime=new Date().getTime();
				}
			}
		}

		this.paint=function(ctx){
			ctx.drawImage(this.frame,this.x,this.y);
		}

		//处理子弹发射 子弹的位置取决于飞机
		this.shootLastTime=0;
		this.shootInterval=200;//发射子弹的间隔
		this.shoot=function(){
			var currentTime=new Date().getTime();
			if(currentTime-this.shootLastTime>=this.shootInterval){
				//到达时间间隔 可以发射子弹
				var bullet=new Bullet(BULLET,this.x+54,this.y);
				bullets[bullets.length]=bullet;
				this.shootLastTime=new Date().getTime();
			}
		}

		//英雄与敌人碰撞后的操作
		this.duang=function(){
			this.down=true;
			this.frameIndex=this.baseFrameCount;
		}
	}

	/*四 子弹*/
	var Bullet=function(config,x,y){
		this.width=config.width;
		this.height=config.height;
		this.frame=config.image;
		this.x=x;
		this.y=y;

		this.canDelete=false;//是否删除子弹

		this.move=function(){
			this.y-=3;
		}

		this.paint=function(ctx){
			ctx.drawImage(this.frame,this.x,this.y);
		}
		//判断子弹是否超出canvas边界
		this.outOfBounds=function(){
			return this.y<(-this.height);
		}

		//子弹与enemy碰撞时的操作 
		this.duang=function(){
			this.canDelete=true;
		}
	}


	/*五 暂停*/
	function Pause(config){
		this.width=config.width;
		this.height=config.height;
		this.speed=1000/config.speed;
		this.frame=null;
		this.frameIndex=0;
		this.lastTime=0;
		this.baseFrameCount=config.baseFrameCount;
		this.x=(WIDTH-this.width)/2;
		this.y=(HEIGHT-this.height)/2;

		this.step=function(){
			var currentTime=new Date().getTime();
			if(currentTime-this.lastTime>=this.speed){
				this.frame=config.frames[this.frameIndex%this.baseFrameCount];
				this.frameIndex++;
				this.lastTime=new Date().getTime();
			}
		}

		this.paint=function(ctx){
			ctx.drawImage(this.frame,this.x,this.y);
		}
	}

	/*六 敌机*/
	//所有敌机数据和图像不一样 其它处理都一样 所以不必对小中大型敌机各创建一个对象 只需传进不同的config
	var Enemy=function(config){
		this.down=false;//是否爆炸
		this.canDelete=false;//是否删除敌机
		this.width=config.width;
		this.height=config.height;
		this.type=config.type;
		this.score=config.score;
		this.frames=config.frames;
		this.frame=null;
		this.frameIndex=0;
		this.baseFrameCount=config.baseFrameCount;
		this.lastTime=0;
		this.life=config.life;//enemy生命
		this.speed=0;//速度
		if(config.minSpeed&&config.maxSpeed){
			this.speed=1000/(Math.random()*(config.maxSpeed-config.minSpeed)+config.minSpeed);
		}else if(config.speed){
			this.speed=1000/config.speed;
		}
		//横纵坐标
		this.x=Math.ceil(Math.random()*(WIDTH-config.width));
		this.y=-config.height;

		this.step=function(){
			if(this.down){
				//播放爆炸图像
				//已经确定this.frameIndex=this.baseFrameCount;
				if(this.frameIndex==this.frames.length){
					this.canDelete=true;
				}else{
					this.frame=this.frames[this.frameIndex];
					this.frameIndex++;
				}
			}
			else{
				//播放基本图像
				if(this.timeInterval()){
				//基本图像切换
				this.frame=this.frames[this.frameIndex%this.baseFrameCount];
				this.frameIndex++;
				//飞机移动
				}
			}
		}

		this.move=function(){
			//飞机移动
			this.y++;
		}

		this.paint=function(ctx){
			//绘制飞机图像
			ctx.drawImage(this.frame,this.x,this.y);
		}

		//加一个方法 检查时间是否到期
		this.timeInterval=function(){
			var currentTime=new Date().getTime();
			if(currentTime-this.lastTime>=this.speed){
				this.lastTime=new Date().getTime();
				return true;
			}
			return false;
		}

		//判断当前飞机是否超出canvas边界
		this.outOfBounds=function(){
			if(this.y>HEIGHT){
				return true;
			}else{
				return false;
			}
		}

		//判断enemy是否与hero或bull碰撞 碰撞时相关联的 碰撞的核心是enemy 所以只要判断enemy是否碰撞 然后再处理hero或bullet
		this.hit=function(c){
			//c的中心点坐标
			var cX=c.x+c.width/2;
			var cY=c.y+c.height/2;

			var leftStart=this.x-c.width/2;
			var leftEnd=this.x+this.width+c.width/2;
			var topStart=this.y-c.height/2;
			var topEnd=this.y+this.height+c.height/2;

			return leftStart<cX && cX<leftEnd && topStart<cY && cY<topEnd;
		}

		//当enemy与其它元素碰撞时的操作方法
		this.duang=function(){
			//生命减少
			this.life--;
			if(this.life==0){
				//切换到爆破状态
				this.down=true;
				score+=this.score;
				this.frameIndex=this.baseFrameCount;//爆炸图片的第一张的角标刚好是this.baseFrameCount;
			}
		}
	}
/***************************************************************************************/
//绘制各个组件
	function paintComponent(){
		//绘制子弹
		for(var i=0;i<bullets.length;i++){
			var bullet=bullets[i];
			bullet.paint(ctx);
		}
		//确保暂停的时候仍能看到飞机
		hero.paint(ctx);

		ctx.font="20px 微软雅黑";
		ctx.fillText("SCORE:"+score,10,20);
		ctx.fillText("LIFE:"+life,400,20);

		//绘制所有敌机
		for(var i=0;i<enemies.length;i++){
			enemies[i].paint(ctx);
		}
	}
//让所有组件动起来 即更新坐标
	function stepComponent(){
		for(var i=0;i<bullets.length;i++){
			var bullet=bullets[i];
			bullet.move();
		}

		//移动所有敌机
		for(var i=0;i<enemies.length;i++){
			enemies[i].step();
			enemies[i].move();
		}
	}
//创建敌机的数据
	var lastTime=new Date().getTime();
	var interval=800;
//根据指定时间差创建不同类型的敌机，将创建好的飞机保存斤enemies数组中
	function componentEnter(){
		var currentTime=new Date().getTime();
		if(currentTime-lastTime>=interval){
			var n=Math.floor(Math.random()*10);
			if(n>=0 && n<=7){//建小飞机
				enemies[enemies.length]=new Enemy(E1);
			}else if(n==8){//建中飞机
				enemies[enemies.length]=new Enemy(E2);
			}else{
				//建大飞机 如果数组中第一个元素不是大型飞机，则创建一个，并且放在第一个位置处，其它飞机位置后移
				if(enemies[0].type!=3){
					enemies.splice(0,0,new Enemy(E3));
				}
			}

			lastTime=new Date().getTime();
		}
	}

	//专门检查enemy是否与hero或bullet碰撞 这个方法放在哪个对象中都不好 因为要传进hero/bullet 应该是全局来管
	function checkHit(){
		for(var i=0;i<enemies.length;i++){
			var enemy=enemies[i];
			if(enemy.down||enemy.canDelete){
				continue;//当enemy处于爆炸或删除的状态时，继续碰撞无效
			}
			//与子弹碰撞
			for(j=0;j<bullets.length;j++){
				var bullet=bullets[j];
				//进行比较
				if(enemy.hit(bullet)){
					enemy.duang();//切换状态
					bullet.duang();
				}
			}
			//与hero碰撞
			if(enemy.down||enemy.canDelete){
				continue;//若enemy处于爆炸或删除状态，就不能再与hero碰撞
			}
			if(enemy.hit(hero)){
				enemy.duang();
				hero.duang();
			}
		}
	}

	//删除多余组件
	function deleteComponent(){
		for(var i=0;i<enemies.length;i++){
			//删除超出下边界的敌机
			if(enemies[i].outOfBounds()){
				enemies.splice(i,1);
			}
			//删除life==0的enemy
			if(enemies[i].canDelete){
				enemies.splice(i,1);
			}
		}
		for(var i=0;i<bullets.length;i++){
			//删除超出上边界的子弹
			if(bullets[i].outOfBounds()){
				bullets.splice(i,1);
			}
			//碰到enemy后的bullet也要删除 若bullet没删除 则会一直与某个enemy碰撞 enemy都有一定的height 一下子就会碰撞很多下 导致一个bullet就能消灭一架enemy 变为无敌状态
			if(bullets[i].canDelete){
				bullets.splice(i,1);
			}
		}
		//判断英雄是否被删除
		if(hero.canDelete){
			life--;//canDelete相当于hero死一次
			if(life==0){
				state=GAME_OVER;
			}else{
				hero=new Hero(HERO);//hero的删除比较特殊，就相当于新创建一个hero
			}
		}
	}


/***************************************************************************************/
	//创建业务对象
	var sky=new Sky(SKY);
	var loading=new Loading(LOADING);
	var hero=new Hero(HERO);
	var pause=new Pause(PAUSEOBJ);
/***************************************************************************************/
	//为canvas添加事件（onclick onmousemove onmouseout）
	canvas.onclick=function(){
		if(state==START){
			state=STARTING;
		}
	}

	//鼠标移动事件 处理hero与鼠标的位置
	canvas.onmousemove=function(e){
		var x=e.offsetX;
		var y=e.offsetY;
		//鼠标移动时改变hero位置
		hero.x=x-HERO.width/2;
		hero.y=y-HERO.height/2;
	}

	canvas.onmouseout=function(e){
		if(state==RUNNING){
			state=PAUSE;
		}
	}

	canvas.onmouseover=function(e){
		if(state==PAUSE){
			state=RUNNING;
		}
	}
/***************************************************************************************/

	//定义计时器 固定频率为1000/100
	setInterval(function(){
		switch(state){
			case START:
				//天空在移动
				sky.step();
				sky.paint(ctx);
				//绘制copyright
				var x=(WIDTH-copyright.naturalWidth)/2;
				var y=(HEIGHT-copyright.naturalHeight)/2;
				ctx.drawImage(copyright,x,y);
				break;
			case STARTING:
				sky.step();
				sky.paint(ctx);

				loading.step();
				loading.paint(ctx);
				break;
			case RUNNING:
				sky.step();
				sky.paint(ctx);

				hero.step();
				hero.paint(ctx);
				hero.shoot();
				checkHit();//检查碰撞
				
				//添加新组件 敌机
				componentEnter();
				stepComponent();
				
				//删除多余组件
				deleteComponent();

				//绘制所有组件
				paintComponent();//这要放最后，否则life为0画不出来
				
				//打印enemies的长度
				//console.log(enemies.length);
				//打印enemies的长度
				//console.log(bullets.length);
				break;
			case PAUSE:
				sky.step();
				sky.paint(ctx);
				paintComponent();
				pause.step();
				pause.paint(ctx);
				break;
			case GAME_OVER:
				ctx.font="bold 24px 微软雅黑";
				var width=ctx.measureText("GAME OVER!").width;
				ctx.fillText("GAME OVER!",(WIDTH-width)/2,300);
				break;
		}
	},1000/100);

</script>
</html>